# A2A 프로토콜과 Apache Kafka를 활용한 분산 AI 에이전트 시스템 구축

## 들어가며

AI 에이전트 기술이 발전하면서, 단일 에이전트로는 해결하기 어려운 복잡한 문제들을 여러 전문화된 에이전트가 협력하여 해결하는 멀티 에이전트 시스템이 주목받고 있습니다. 하지만 기존의 에이전트 간 통신 방식은 대부분 HTTP 기반의 직접 연결에 의존하여, 확장성과 안정성 측면에서 한계를 보입니다.

이 글에서는 Google의 A2A(Agent-to-Agent) 프로토콜을 Apache Kafka 위에 구현하여, 확장 가능하고 안정적인 분산 AI 에이전트 시스템을 구축한 사례를 소개합니다. 게임 밸런스 자동화라는 실제 사용 사례를 통해, 이 아키텍처가 어떻게 복잡한 멀티 에이전트 워크플로우를 효과적으로 지원하는지 보여드리겠습니다.

## 문제 정의: 기존 에이전트 통신의 한계

### HTTP 기반 통신의 구조적 문제

전통적인 멀티 에이전트 시스템은 에이전트 간 직접 HTTP 연결을 사용합니다. 이 방식은 간단해 보이지만, 시스템이 커질수록 여러 문제가 발생합니다.

**연결 복잡도의 기하급수적 증가**

에이전트가 3개일 때는 6개의 연결만 관리하면 되지만, 10개가 되면 90개의 연결을 관리해야 합니다. 각 에이전트는 다른 모든 에이전트의 URL을 알고 있어야 하며, 한 에이전트의 주소가 변경되면 모든 연결을 업데이트해야 합니다.

**장애 전파의 위험**

한 에이전트에 문제가 생기면, 그 에이전트와 직접 연결된 모든 에이전트가 영향을 받습니다. 타임아웃이 발생하거나 에러가 전파되어 전체 시스템의 안정성이 저하됩니다.

**확장의 어려움**

새로운 에이전트를 추가하려면 기존 에이전트들의 설정을 모두 변경해야 합니다. 로드 밸런싱을 위해 에이전트 인스턴스를 늘리는 것도 복잡한 작업이 됩니다.

**관찰성의 부재**

에이전트 간 통신이 분산되어 있어, 전체 시스템의 상호작용을 추적하고 디버깅하기가 매우 어렵습니다. 어떤 에이전트가 어떤 에이전트를 호출했는지, 얼마나 시간이 걸렸는지 파악하기 위해서는 각 에이전트의 로그를 일일이 확인해야 합니다.

## 솔루션: Hub-Spoke 아키텍처

### 핵심 아이디어

우리의 솔루션은 간단하지만 강력한 아이디어에서 출발합니다: **모든 에이전트 간 통신을 중앙의 Kafka Hub를 통하도록 하는 것**입니다.

```
기존 방식 (Mesh):                새로운 방식 (Hub-Spoke):
                                 
A ←→ B                                    Kafka
 ↘ ↙                                    ↗  ↑  ↖
  C                                   A   B   C
```

이 구조에서 각 에이전트는:
- Kafka에만 연결하면 됩니다 (다른 에이전트의 위치를 알 필요 없음)
- 메시지를 토픽에 발행하고 구독하기만 하면 됩니다
- 다른 에이전트의 장애로부터 격리됩니다

### A2A 프로토콜의 역할

A2A 프로토콜은 에이전트 간 상호작용을 위한 표준화된 방법을 제공합니다. 우리는 이 프로토콜의 전송 계층만 HTTP에서 Kafka로 교체했습니다. 이를 통해:

- **멀티턴 대화**: 사용자가 "승률?"이라고 물으면 "어떤 종족?"이라고 되묻고, "저그"라고 답하면 "저그 승률 50%"라고 답하는 자연스러운 대화
- **작업 상태 관리**: 진행 중, 완료, 추가 입력 필요 등의 상태를 체계적으로 관리
- **스트리밍 응답**: 긴 답변을 실시간으로 스트리밍하여 사용자 경험 개선

### 게임 밸런스 자동화 시나리오

우리가 구현한 시스템은 게임 밸런스 조정을 자동화합니다:

**Balance Agent (코디네이터)**
- 사용자 질문을 받아 어떤 분석이 필요한지 판단
- 필요한 다른 에이전트들을 호출하여 정보 수집
- 수집된 정보를 종합하여 최종 답변 생성

**Data Agent (통계 분석가)**
- 게임 로그 데이터베이스에서 승률, 평균 게임 시간 등 통계 추출
- 종족별, 맵별, 시간대별 등 다양한 관점의 분석 제공

**CS Agent (고객 의견 분석가)**
- 게시판의 컴플레인과 피드백 수집
- 유저들이 실제로 느끼는 밸런스 문제 파악

예를 들어, "테란이 너무 강한가요?"라는 질문이 들어오면:
1. Balance Agent가 질문을 받음
2. Data Agent에게 테란 승률 조회
3. CS Agent에게 테란 관련 컴플레인 조회
4. 두 정보를 종합하여 "통계상 테란 승률은 52%로 약간 높지만, 유저 컴플레인은 많지 않습니다"라고 답변

## 아키텍처 상세 설계

### Kafka 토픽 구조

각 에이전트는 두 개의 전용 토픽을 가집니다:

- `agent.{name}.requests`: 이 에이전트로 들어오는 요청
- `agent.{name}.responses`: 이 에이전트가 보내는 응답

추가로 `agent.registry` 토픽에서 모든 에이전트가 자신의 능력을 공유합니다.

이 구조의 장점:
- **명확한 책임**: 각 토픽의 역할이 분명함
- **독립적 확장**: 각 에이전트의 트래픽에 따라 파티션 수 조정 가능
- **격리**: 한 에이전트의 문제가 다른 에이전트의 토픽에 영향 없음

### 요청-응답 매칭: Correlation ID

Kafka는 기본적으로 비동기 메시징 시스템입니다. 하지만 에이전트 간 통신은 종종 동기적 요청-응답 패턴을 필요로 합니다. 이를 해결하기 위해 **Correlation ID**를 사용합니다.

**동작 방식:**
1. Balance Agent가 Data Agent에게 요청할 때 고유한 ID(예: "abc-123") 생성
2. 이 ID를 Kafka 메시지의 Key로 사용하여 `agent.data.requests`에 발행
3. Data Agent가 처리 후 같은 ID를 Key로 사용하여 `agent.data.responses`에 응답 발행
4. Balance Agent는 백그라운드에서 응답 토픽을 구독하며, ID가 "abc-123"인 메시지를 찾아 매칭

이 방식으로 비동기 메시징 위에서 동기적 요청-응답 패턴을 구현합니다.

### 멀티턴 대화: Context ID

Correlation ID는 단일 요청-응답을 매칭하지만, 대화는 여러 턴으로 이어집니다. 이를 위해 **Context ID**를 추가로 사용합니다.

**시나리오:**
- 1턴: "승률?" → Correlation ID: "abc-123", Context ID: "ctx-001" (새로 생성)
- 응답: "어떤 종족?" (input-required 상태, Context ID: "ctx-001" 반환)
- 2턴: "저그" → Correlation ID: "def-456" (새로 생성), Context ID: "ctx-001" (유지)
- 응답: "저그 승률 50%" (Context ID로 이전 대화 참조)

**핵심 차이:**
- Correlation ID: 매 요청마다 새로 생성, 요청-응답 매칭용
- Context ID: 대화 전체에서 유지, 대화 맥락 보존용

### 동적 에이전트 발견

시스템 시작 시 각 에이전트는 `agent.registry` 토픽에 자신의 정보를 발행합니다:
- 이름과 설명
- 제공하는 기능(Skills) 목록
- 지원하는 기능(스트리밍, 멀티턴 등)

다른 에이전트들은 이 토픽을 읽어 사용 가능한 에이전트와 그들의 능력을 동적으로 발견합니다. 새로운 에이전트가 추가되면 자동으로 발견되어 사용 가능해집니다.

## 구현 핵심 요소

### KafkaTransport: A2A와 Kafka의 연결고리

A2A 프로토콜은 `ClientTransport`라는 인터페이스를 정의합니다. 우리는 이를 Kafka로 구현한 `KafkaTransport` 클래스를 만들었습니다.

**주요 책임:**
- Producer로 요청 메시지 발행
- Consumer로 응답 메시지 수신 (백그라운드)
- Correlation ID로 요청과 응답 매칭
- 타임아웃 관리 (40초 내 응답 없으면 에러)

**비동기 처리의 핵심:**

별도의 백그라운드 태스크가 지속적으로 응답 토픽을 구독합니다. 응답이 도착하면 Correlation ID를 확인하고, 해당 요청을 기다리는 곳에 전달합니다. 이를 통해 여러 요청을 동시에 처리할 수 있습니다.

### KafkaConsumerHandler: 서버 측 처리

각 에이전트는 자신의 요청 토픽을 구독하는 Consumer를 실행합니다. 메시지가 도착하면:

1. A2A 프로토콜에 맞게 파싱
2. `DefaultRequestHandler`에 전달하여 실제 에이전트 로직 실행
3. 결과를 A2A 형식으로 변환
4. 응답 토픽에 발행 (같은 Correlation ID 사용)

### Task 생성과 상태 관리

A2A 프로토콜의 핵심 개념인 Task는 `DefaultRequestHandler`에서 자동으로 생성됩니다. Task는 다음 상태를 가질 수 있습니다:

- **pending**: 작업 대기 중
- **running**: 처리 중
- **completed**: 완료 (결과 포함)
- **input-required**: 추가 입력 필요 (멀티턴 대화)
- **failed**: 실패 (에러 정보 포함)

이 상태 관리를 통해 복잡한 비동기 작업을 체계적으로 추적할 수 있습니다.

## AWS 서비스 통합

### Amazon MSK: 프로덕션 Kafka

로컬 개발에서는 Docker로 Kafka를 실행하지만, 프로덕션에서는 Amazon MSK를 사용합니다.

**MSK의 장점:**
- **관리 부담 감소**: 브로커 프로비저닝, 패치, 모니터링을 AWS가 담당
- **고가용성**: 3개 가용 영역에 자동 복제
- **보안**: VPC 격리, 전송 중/저장 시 암호화, IAM 인증
- **확장성**: 브로커 추가나 스토리지 확장이 간단

**권장 구성:**

개발/테스트:
- kafka.t3.small 인스턴스
- 3개 브로커
- 100GB 스토리지/브로커
- 월 약 $200

프로덕션:
- kafka.m5.large 인스턴스
- 3-6개 브로커
- 1TB GP3 스토리지/브로커
- 월 약 $1,500

### Amazon Bedrock: LLM 통합

각 에이전트는 Amazon Bedrock의 foundation model을 사용합니다.

**모델 선택 가이드:**

| 모델 | 특징 | 적합한 용도 |
|------|------|------------|
| Nova Lite | 빠르고 저렴 | 단순 분류, 빠른 응답 |
| Claude 3 Haiku | 균형잡힌 성능 | 일반적인 대화 |
| Claude 3 Sonnet | 높은 추론 능력 | 복잡한 분석, 종합 |

우리 시스템에서는:
- Data Agent: Nova Lite (통계 조회는 단순)
- CS Agent: Claude 3 Haiku (텍스트 분석)
- Balance Agent: Claude 3 Sonnet (종합 판단)

### CloudWatch: 관찰성

분산 시스템에서 관찰성은 필수입니다. 우리는 세 가지 수준의 모니터링을 구현했습니다:

**메트릭 수집:**
- 에이전트별 요청 수, 응답 시간, 에러율
- Kafka 토픽별 메시지 처리량, 지연시간
- Bedrock 토큰 사용량 (비용 추적)

**로그 통합:**
- 모든 에이전트의 로그를 CloudWatch Logs로 중앙 집중
- 구조화된 로그로 검색과 분석 용이
- Correlation ID와 Context ID를 로그에 포함하여 추적 가능

**분산 추적:**
- AWS X-Ray로 요청의 전체 흐름 시각화
- 어떤 에이전트가 어떤 에이전트를 호출했는지 한눈에 파악
- 병목 지점과 느린 구간 식별

## 성능과 확장성

### 벤치마크 결과

로컬 Kafka와 Amazon MSK에서 성능을 측정했습니다:

**처리량:**
- 로컬: 에이전트당 1,000 메시지/초
- MSK: 에이전트당 10,000+ 메시지/초

**지연시간:**
- 로컬: 평균 50ms, P99 200ms
- MSK: 평균 80ms, P99 300ms

MSK가 약간 더 높은 지연시간을 보이지만, 이는 네트워크 거리 때문이며 안정성과 확장성을 고려하면 충분히 수용 가능한 수준입니다.

### 확장 전략

**수평 확장:**

각 에이전트는 Consumer Group을 사용하여 여러 인스턴스를 실행할 수 있습니다. Kafka가 자동으로 메시지를 분산하여 로드 밸런싱합니다.

예: Data Agent를 3개 인스턴스로 실행하면, 각 인스턴스가 요청의 1/3씩 처리합니다.

**수직 확장:**

트래픽이 많은 에이전트의 토픽은 파티션 수를 늘려 병렬 처리를 증가시킵니다.

예: `agent.data.requests` 토픽을 3개 파티션에서 9개 파티션으로 증가

### 비용 최적화

**MSK 비용:**
- 브로커 인스턴스 비용이 대부분
- 트래픽이 적은 시간대에는 브로커 수 감소 고려
- GP3 스토리지 사용으로 비용 절감

**Bedrock 비용:**
- 토큰 사용량에 따라 과금
- 간단한 작업은 저렴한 모델 사용
- 프롬프트 캐싱으로 반복 비용 절감

**모니터링:**
- 일일 비용을 CloudWatch 메트릭으로 추적
- 예상치 못한 비용 증가 시 알림 설정

## 실전 활용 패턴

### 순차 실행 패턴

여러 에이전트를 순서대로 호출하여 파이프라인 구성:

1. Data Agent로 통계 수집
2. 그 결과를 CS Agent에 전달하여 유저 피드백과 비교
3. 최종적으로 Balance Agent가 종합 판단

**장점:** 각 단계의 결과가 다음 단계의 입력이 되어 점진적으로 정보 축적

### 병렬 실행 패턴

여러 에이전트를 동시에 호출하여 시간 단축:

1. Data Agent와 CS Agent를 동시에 호출
2. 두 결과가 모두 도착하면 Balance Agent가 종합

**장점:** 전체 처리 시간이 가장 느린 에이전트의 시간으로 단축

### 조건부 실행 패턴

첫 번째 에이전트의 결과에 따라 다음 행동 결정:

1. Data Agent로 승률 확인
2. 승률이 비정상이면 CS Agent로 컴플레인 확인
3. 정상이면 바로 응답

**장점:** 불필요한 호출을 줄여 비용과 시간 절약

## 다른 도메인으로의 확장

이 아키텍처는 게임 밸런스 외에도 다양한 분야에 적용 가능합니다:

### 고객 지원 자동화

- **Ticket Agent**: 고객 문의 분류
- **Knowledge Agent**: 지식베이스 검색
- **Resolution Agent**: 해결책 생성

### 금융 리스크 분석

- **Market Agent**: 시장 데이터 분석
- **Risk Agent**: 포트폴리오 리스크 평가
- **Compliance Agent**: 규정 준수 확인

### 콘텐츠 생성 파이프라인

- **Research Agent**: 주제 조사
- **Writer Agent**: 초안 작성
- **Editor Agent**: 편집 및 개선

## 모범 사례와 교훈

### 설계 원칙

**느슨한 결합:**
에이전트는 서로의 구현을 알 필요 없이 메시지만 교환합니다. 한 에이전트를 변경해도 다른 에이전트에 영향이 없습니다.

**단일 책임:**
각 에이전트는 하나의 명확한 역할만 수행합니다. Data Agent는 데이터만, CS Agent는 피드백만 담당합니다.

**멱등성:**
같은 요청을 여러 번 처리해도 같은 결과가 나와야 합니다. 네트워크 문제로 재시도가 발생해도 안전합니다.

### 운영 교훈

**타임아웃의 중요성:**
모든 에이전트 호출에 적절한 타임아웃을 설정해야 합니다. 한 에이전트가 응답하지 않아도 전체 시스템이 멈추지 않도록 합니다.

**점진적 롤아웃:**
새로운 에이전트나 기능은 작은 트래픽부터 시작하여 점진적으로 확대합니다. 문제 발생 시 빠르게 롤백할 수 있습니다.

**관찰성 우선:**
처음부터 로깅, 메트릭, 추적을 구현해야 합니다. 문제가 발생한 후에 추가하기는 어렵습니다.

## 결론

A2A 프로토콜과 Kafka의 결합은 분산 AI 에이전트 시스템의 새로운 가능성을 열어줍니다. 이 아키텍처는:

**확장성:** 에이전트를 추가하거나 인스턴스를 늘리는 것이 간단합니다.

**안정성:** 한 에이전트의 장애가 다른 에이전트에 영향을 주지 않습니다.

**관찰성:** 모든 상호작용을 추적하고 분석할 수 있습니다.

**유연성:** 다양한 실행 패턴(순차, 병렬, 조건부)을 지원합니다.

### 향후 방향

**스키마 레지스트리 통합:**
메시지 형식의 버전 관리로 호환성 보장

**멀티 리전 배포:**
글로벌 서비스를 위한 지역 간 복제

**고급 라우팅:**
우선순위, 배치 처리 등 더 정교한 메시지 흐름

**오케스트레이션 DSL:**
복잡한 워크플로우를 선언적으로 정의

이 글에서 소개한 패턴과 경험이 여러분의 AI 에이전트 시스템 구축에 도움이 되기를 바랍니다.

---

## 참고 자료

- [Amazon MSK 개발자 가이드](https://docs.aws.amazon.com/msk/)
- [Amazon Bedrock 사용자 가이드](https://docs.aws.amazon.com/bedrock/)
- [Strands Agents SDK](https://strandsagents.com/)
- [A2A 프로토콜 사양](https://github.com/google/agent-to-agent)

## 저자 소개

질문이나 피드백이 있으시면 댓글로 남겨주세요!
